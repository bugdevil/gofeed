package main

import (
	"log"
	"net/http"
	"net/url"
	"regexp"
	"strings"
)

// return later time
func GetLaterTimeStr(a, b string) (result string, err error) {
	timeA, err := http.ParseTime(a)
	if nil != err {
		log.Printf("[ERROR] failed to parse string %s as http time", a)
		return
	}
	timeB, err := http.ParseTime(b)
	if nil != err {
		log.Printf("[ERROR] failed to parse string %s as http time", b)
		return
	}

	if timeA.After(timeB) {
		result = a
	} else {
		result = b
	}

	return
}

// normalize url
func NormalizeURLStr(rawString string) string {
	if !strings.HasPrefix(rawString, HTTP_SCHEME) && !strings.HasPrefix(rawString, HTTPS_SCHEME) {
		rawString = HTTP_SCHEME + rawString
	}
	return rawString
}

// FeedTarget should be generated by ParseJsonConfig function
// find index regexp
func FindIndexReg(feedTar *FeedTarget, feedURL *url.URL) *regexp.Regexp {
	if 1 == len(feedTar.IndexRegs) {
		return feedTar.IndexRegs[0]
	}
	for i := 0; i < len(feedTar.URLs); i++ {
		if feedTar.URLs[i] == feedURL {
			return feedTar.IndexRegs[i]
		}
	}
	return nil
}

// FeedTarget should be generated by ParseJsonConfig function
// find content regexp
func FindContentReg(feedTar *FeedTarget, feedURL *url.URL) *regexp.Regexp {
	if 1 == len(feedTar.ContentRegs) {
		return feedTar.ContentRegs[0]
	}
	for i := 0; i < len(feedTar.URLs); i++ {
		if feedTar.URLs[i] == feedURL {
			return feedTar.ContentRegs[i]
		}
	}
	return nil
}
